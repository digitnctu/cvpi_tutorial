
CVPI 是一個結合Verilog RTL和C/C++的程式框架。Verilog是DUT(Design Under Test)使用的RTL語言；而C/C++是通用的程式語言，主要是用於驗證DUT正確性。CVPI即是利用VERILOG標準(IEEE 1364)裏的VPI方式將RTL和C/C++結合在一起。

=====
動機
=====

VPI是在Verilog標準中定義的C界面。Verilog語言讓應用程式透過VPI可以存取和更改Verilog訊號的值、也可以註冊在模擬期間的特定時刻呼叫特定的C函數(也就是callback函數)、或者取消之前註冊的callback函數。

雖然VPI是一個很方便的界面，然而由於它過於原始，所以應用方式顯得有些麻煩。由於上述原因，CVPI引進了task，reason和sig_base概念，包裝VPI的界面使得應用方式會比較容易。

CVPI主要是用於驗證DUT正確性。
然而驗證DUT是一件困難且複雜的工作。這個工作主要的目的是確認DUT功能正確值得信賴。
為了完成工作需要不同條件和輸入對DUT測試，其中包含正常工作環境不可能出現的錯誤狀況(Error case)，以確保錯誤狀況不會將DUT鎖死；也包含罕見的輸入條件，也要能正常工作(Corner case)。上述輸入條件產生，有時需要特定的時序輸入或者特定的輸入數值。
由於VPI界面定義於Verilog標準，透過它可以存取和更改Verilog訊號的值，也可以註冊特定模擬時刻執行個別函數。
因此VPI在產生驗證時的輸入條件符合要求，而有一定的優勢；而CVPI包裝VPI的界面使之使用上更方便，所以CVPI也具有輸入DUT特定輸入條件的能力。

驗證DUT正確性除了困難且複雜外，通常也有很多數量相對眾多的測試項目(pattern)。使用通用C語言，能更容易產生驗證項目所需的輸入條件。更進一步來說，經過精心設計我們可能做到自動化產生輸入條件，數量相對眾多項目的產生也就容易許多。

===========
CVPI的優勢
===========

CVPI包裝C語言的VPI界面，可以用來於模擬期間於特定時刻更動Verilog訊號的值。除了這個優點外，還有其它好處。

--------------
編譯工具的分離
--------------

驗證DUT正確性的動作會有數量眾多的測試項目，在DUT和驗證程式無法分離編譯會產生一個問題。每當更改或者產生一個新的測試項目，DUT和驗證程式都需要重新編譯，這個動作會花很多冗餘的時間。

CVPI將DUT和驗證程式使用不同語言，利用各自的工具編譯。工具的不同帶來了不便，但也帶來了DUT和驗證程式碼需要分開來編譯的事實。分開編譯意謂著我們可以在DUT RTL不需要重新編譯或者更動下，仍能透過更動驗證程式碼來達到確認DUT是否符合預期。每當更改或新増測試項時，只需編譯測試程式從而減少DUT編譯時間。

更進一步來說：因為分開編譯，我們可以在不知道DUT RTL原始碼而僅有編譯後的結果的情況下，進行驗證DUT RTL。這種僅有編譯結果即可驗證的作法讓我們有機會固定DUT版本下，驗證DUT的正確性。從另一個角度想：這種方法帶來驗證DUT RLT外包的可能性，從而進一步減少開發成本的可能。

---------
使用C/C++
---------

C/C++作為一種通用語言，廣泛地為人所熟知，在執行速度和開發難度上有著一定的平衡。這個語言也時常拿來做為驅動程式、演算法或者其它腳本語言(如PYTHON/PERL/...)的溝通語言。

..
  驗證程式碼使用C/C++語言，如果軟體/演算法也是使用相同語言，這意謂著我們可以將軟體當作是驗證程式的一個部份，從而達到軟體和硬體共同一起模擬的想法。

~~~~~~~~
驅動程式
~~~~~~~~

SW在開發驗動程式時，SW會使用先前和HW共同協調的驅動程式界面，完成驅動程式。當C語言是SW拿來做為驅動程式語言時，由於CVPI和SW使用相同的語言，使得兩者溝通變得很容易。

如果在RTL階段就透過CVPI實現了驅動程式界面，SW所寫的驅動程式就可以直接使用來驗證DUT的正確性。這帶來了一個很重大的優勢：驅動程式不用等到IC出來，在DUT RTL開發階段就可以一起驗證驅動程式和DUT RTL界面的正確性。與此同時，SW也能提早開發階段，加速了IC推出的時程。

~~~~~~
演算法
~~~~~~

我們假設DUT想要實現某一個特定的演算法(假定是影像處理或者壓縮)。可以想見的是DUT需要能從上家block拿到要處理的資料，處理所收到的資料，最後再將處理完的資料傳到下家block。

驗證程式為了驗證DUT確實實現演算法，驗證程式擷取DUT從上家block拿到的資料或者驗證程式直接餵資料給DUT；而後驗證程式將擷取到的資料或者餵給DUT的資料應用在演算法；最後再觀察DUT處理完的資料和自己應用在演算法的資料做比對，得出DUT是否確實實現演算法的結論。

在上述過程中，我們可以發現如果演算法和驗證程式同為C語言時，我們可以很容易地將演算法內嵌到驗證程式中。內嵌的作法要求驗證程式做好擷取或餵資料以及觀察比較的工作。相對於DUT而言，工作量少了許多且更能保證處理後的資料更符合演算法的結果。

內嵌演算法的驗證程式也比區塊式的驗證方式來的靈活和更接近錯誤發生的時刻。內嵌演算法的驗證程式是拿到足夠資料即可呼叫演算法計算並等待比對DUT的資料。足夠資料的數據量是演算法來定義的，而非區塊式驗證方式的區塊大小決定。

更進一步而言，如果我們可以固定演算法的呼叫界面，且將演算法編譯成動態程式庫，那我們可以更方便的更換演算法。在保護演算法的原則下，給予外部人員試驗演算法程式庫以方便外部人員發展驗證程式；而在外部人員遞交驗證程式後，真正執行驗證DUT正確性時，由於演算法是動態程式庫，我們可以換回真正演算法，達成保護演算法的目的。

--------
腳本驗證
--------

腳本語言如(Python、Perl、Tcl等)有高階資料結構，且是直譯語言。直譯語言不需要編譯程式，可以直接執行程式。在做小程式或者利用改變參數轉變程式的結果，腳本語言就帶來便利。驗證程式有大數量的測試項目(pattern)，可以想像項目之間應該有相同的地方也有相異的地方。如果利用腳本語言直譯特性，項目相同地方使用驗證函數實現，相異的地方就很適合利用腳本語言來完成。如果測試項目間存在有大同小異的地方，這麼做就具有方便產生測試項目的優勢。

要做到上述想法，我們需要將腳本語言內嵌到驗證程式中。上面舉例的腳本語言(Python、Perl、Tcl)都具有C界面可以內嵌語言到程式裏面，或者可以將C函數擴展成為腳本的函數庫。當我們內嵌腳本語言到驗證程式，同時將CVPI框架擴展為腳本函數庫。當呼叫驗證程式時，由於內嵌腳本語言我們可以執行腳本的程式。這個腳本程式可以使用我們為它擴展的CVPI框架，從而可以和讀取或更改verilog的訊號，也有機會註冊callback函數。

上面描述情境，由於這腳本程式不需要重新編譯，產生測試項目(pattern)就比較簡單了。容易產生測試項目同時也意謂著自動化產生測試項目(pattern)可以做到。

--------
模組取代
--------

在上面描述演算法中，我們提到驗證程式需要擷取或者餵資料，而後處理資料，最後比較資料。就處理資料而言，DUT和驗證程式要得到一樣的處理後資料；就DUT輸入/輸出時序而言，DUT和驗證程式是相對的。DUT的輸入訊號來自驗證程式的輸出；驗證程式的輸入訊號來自DUT的輸出。

想像一下有另一個驗證程式B要驗證上面的驗證程式A。驗證程式B會有和DUT一樣的資料處理結果；在驗證程式和被驗證對象的輸入/輸出時序是相對的基礎上，因為DUT和驗證程式B同樣相對於驗證程式A，可以得到驗證程式B和DUT是可以相互取代的。

再進一步而言，由於DUT有強大的處理能力，單一個模組實現會過於複雜且巨大。將DUT分成若干的模組合理的想法。可以想像每個DUT的模組就是一個小的DUT，如上述所言驗證程式和DUT是可以相互取代，我們就能寫驗證程式取代DUT模組。

簡化且加新DUT的驗證。由於模組相對整個DUT而言簡單，驗證模組相對於DUT也同理簡單；DUT模組的驗證也不再受到上/下家DUT模組實作時程限制，在驗證程式實現快於DUT的基礎上，這種作法加速了整體DUT的驗證速度。

..
	驗證程式使用C/C++實現的演算法，利用CVPI實現模組間的時序。驗證程式只有實現模組界面時序，使得它發展的速度比較快。發展速度快加上VPI能透過hierarachy path改變verilog 變數值，讓我們可以利用CVPI做模組取代的作法加速DUT的發展。

..
	具體的做法是：我們可以使用只有模組I/O界面的空模組合成DUT，驗證程式和演算法實現各個模組，以確認架構是否符合要求，以及各模組時序的規格。隨之而後的是，DUT逐一完成空模組實現；當一模組實現時，我們可以將RTL實現的模組取代由驗證程式和演算法實現相應模組，同時之前驗證架構的pattern此時也能用來驗證目前使用RTL實現的模組是否正確。

---------------
驗證靈活-即時性
---------------

如在腳本語言描述，我們可以使用腳本語言來做數量眾多測試項目相異的地方。進一步分析這些相異的地方，我覺得可以分成兩個部份:改變訊號的當前數值，以及更改的訊號時刻。這兩部份可以由腳本語言在CVPI幫助下完成；也可以在由測試程式做更改時刻的部份，然後呼叫動態程式庫的方式得到改變訊號的數值。

上述的作法，由於訊號數值由動態程式庫而來，其餘都由驗證程式來做，產生測試項目(pattern)也相對簡單了，也有機會產生自動化產生測試項目(pattern)。

..
	要驗證DUT是否可靠需要有很多的行為要確認，這意謂需要有很多的pattern。但是當我們比較pattern間的關係後，可能會發現有些pattern之間存在有很多相似的地方，而不同的地方有限。我們期望這些不同的地方參數化，那我們就可能利用驗證程式依照這些參數產生一個pattern。這樣參數化的過程會讓pattern的產生容易更自動化。

..
	進一步分析後，我們發現有些參數一個很特别性質，即參數下達的時間點有即時性，也就是説在驗證過程的某一個特定的時間才有效，過後即失去作用。關於這一點因為VPI本身是Verilog標準的一部份，同時具有能讓verilog於特定時點調用回呼程式（callback function）的功能，所以使用VPI能讓參數的即時性獲得保障。

=====
結論
=====

CVPI框架包裝VPI，主要目的可以方便地讀取/更改訊號，或者註冊/取消callback函數。除了方便外，CVPI有下列的好處:分離設計/驗證工具帶來快速產生測試項目(pattern)，甚至有機會外包驗證、在RTL階段提供驅動程式界面、演算法RTL快速驗證、整合腳本語言加速產生測試項目(pattern)、模組取代。

..
  -----------
  DEBUG的想法
  -----------
..
	參數本身具有即時性的特性會造成一些問題：目前的pattern是依據那一個參數值做的。這個問題我們想到的解法是在C/C++這一端有一個共同的模擬參考時間，將這個時間和參數綁定在一起；但是我們發現如果參數在RTL端，那我們有機會利用RTL既有的工具將參數和模擬時間自動綁定。

